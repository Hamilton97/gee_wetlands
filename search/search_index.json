{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to gee_wetlands","text":"<p>Python Lib for doing wetland classifications in google earth engine</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://Hamilton97.github.io/gee_wetlands</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/Hamilton97/gee_wetlands/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>gee_wetlands could always use more documentation, whether as part of the official gee_wetlands docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/Hamilton97/gee_wetlands/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up gee_wetlands for local development.</p> <ol> <li> <p>Fork the gee_wetlands repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/gee_wetlands.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv gee_wetlands\n$ cd gee_wetlands/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 gee_wetlands tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/Hamilton97/gee_wetlands/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"gee_wetlands/","title":"gee_wetlands module","text":""},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ALOSPalsar2","title":"<code> ALOSPalsar2            (ImageCollection)         </code>","text":"<p>A class representing the ALOS PALSAR-2 Image Collection in Google Earth Engine.</p> <p>This class extends the <code>ee.ImageCollection</code> class and provides additional functionality specific to the ALOS PALSAR-2 data.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class ALOSPalsar2(ee.ImageCollection):\n    \"\"\"\n    A class representing the ALOS PALSAR-2 Image Collection in Google Earth Engine.\n\n    This class extends the `ee.ImageCollection` class and provides additional functionality\n    specific to the ALOS PALSAR-2 data.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"JAXA/ALOS/PALSAR/YEARLY/SAR_EPOCH\")\n\n    def select(self, args: Any = None) -&gt; ALOSPalsar2:\n        if args is None:\n            return super().select('H.*')\n        return super().select(args)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ALOSPalsar2.select","title":"<code>select(self, args=None)</code>","text":"<p>Select bands from each image in a collection.</p> <p>Parameters:</p> Name Type Description Default <code>selectors</code> <p>An array of names, regexes or numeric indices specifying the bands to select.</p> required <code>names</code> <p>An array of strings specifying the new names for the selected bands.  If supplied, the length must match the number of bands selected.</p> required <code>*args</code> <code>Any</code> <p>Selector elements as varargs.</p> <code>None</code> <p>Returns:</p> Type Description <code>ALOSPalsar2</code> <p>The image collection with selected bands.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def select(self, args: Any = None) -&gt; ALOSPalsar2:\n    if args is None:\n        return super().select('H.*')\n    return super().select(args)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.AssessmentTable","title":"<code> AssessmentTable        </code>","text":"<p>Represents an assessment table for error matrix data.</p> <p>Attributes:</p> Name Type Description <code>table</code> <code>ee.FeatureCollection</code> <p>The assessment table generated from the error matrix data.</p> <p>Methods</p> <p>init(self, matrix: ErrorMatrix) -&gt; None: Initializes the AssessmentTable object. save_to_drive(self, file_name: str, folder_name: str, start: bool = True) -&gt; ee.batch.Task: Saves the assessment table to Google Drive. _make_assessment_table(data: ErrorMatrix) -&gt; ee.FeatureCollection: Creates the assessment table from the error matrix data.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class AssessmentTable:\n    \"\"\"\n    Represents an assessment table for error matrix data.\n\n    Attributes:\n        table (ee.FeatureCollection): The assessment table generated from the error matrix data.\n\n    Methods:\n        __init__(self, matrix: ErrorMatrix) -&gt; None: Initializes the AssessmentTable object.\n        save_to_drive(self, file_name: str, folder_name: str, start: bool = True) -&gt; ee.batch.Task: Saves the assessment table to Google Drive.\n        _make_assessment_table(data: ErrorMatrix) -&gt; ee.FeatureCollection: Creates the assessment table from the error matrix data.\n    \"\"\"\n\n    def __init__(self, matrix: ErrorMatrix) -&gt; None:\n        self.table = self._make_assessment_table(matrix)\n\n    def save_to_drive(self, file_name: str, folder_name: str, start: bool = True) -&gt; ee.batch.Task:\n        \"\"\"\n        Saves the assessment table to Google Drive.\n\n        Args:\n            file_name (str): The name of the file to be saved.\n            folder_name (str): The name of the folder in Google Drive where the file will be saved.\n            start (bool, optional): Whether to start the export task immediately. Defaults to True.\n\n        Returns:\n            ee.batch.Task: The export task for saving the assessment table.\n        \"\"\"\n        task = ee.batch.Export.table.toDrive(\n            collection=self.table,\n            description=\"\",\n            folder=folder_name,\n            fileNamePrefix=file_name,\n            fileFormat='GeoJSON'\n        )\n\n        if start:\n            task.start()\n\n        return task\n\n    @staticmethod\n    def _make_assessment_table(data: ErrorMatrix) -&gt; ee.FeatureCollection:\n        \"\"\"\n        Creates the assessment table from the error matrix data.\n\n        Args:\n            data (ErrorMatrix): The error matrix data.\n\n        Returns:\n            ee.FeatureCollection: The assessment table generated from the error matrix data.\n        \"\"\"\n        return ee.FeatureCollection([\n            ee.Feature(None, {'matrix': data.error_matrix}),\n            ee.Feature(None, {'order': data.order}),\n            ee.Feature(None, {'consumers': data.consumers_accuracy}),\n            ee.Feature(None, {'producers': data.producers_accuracy}),\n            ee.Feature(None, {'overall': data.accuracy})\n        ])\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.AssessmentTable.save_to_drive","title":"<code>save_to_drive(self, file_name, folder_name, start=True)</code>","text":"<p>Saves the assessment table to Google Drive.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the file to be saved.</p> required <code>folder_name</code> <code>str</code> <p>The name of the folder in Google Drive where the file will be saved.</p> required <code>start</code> <code>bool</code> <p>Whether to start the export task immediately. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.batch.Task</code> <p>The export task for saving the assessment table.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def save_to_drive(self, file_name: str, folder_name: str, start: bool = True) -&gt; ee.batch.Task:\n    \"\"\"\n    Saves the assessment table to Google Drive.\n\n    Args:\n        file_name (str): The name of the file to be saved.\n        folder_name (str): The name of the folder in Google Drive where the file will be saved.\n        start (bool, optional): Whether to start the export task immediately. Defaults to True.\n\n    Returns:\n        ee.batch.Task: The export task for saving the assessment table.\n    \"\"\"\n    task = ee.batch.Export.table.toDrive(\n        collection=self.table,\n        description=\"\",\n        folder=folder_name,\n        fileNamePrefix=file_name,\n        fileFormat='GeoJSON'\n    )\n\n    if start:\n        task.start()\n\n    return task\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.DataCube","title":"<code> DataCube            (ImageCollection)         </code>","text":"<p>A class representing a data cube in Google Earth Engine.</p> <p>This class extends the <code>ee.ImageCollection</code> class and provides additional methods for processing and manipulating the data cube.</p> <p>Attributes:</p> Name Type Description <code>BANDS</code> <code>list</code> <p>A list of spectral bands in the data cube.</p> <p>Methods</p> <p>select_spectral_bands: Selects the spectral bands based on a pattern. rename_bands: Renames the spectral bands in the data cube. preproces: Preprocesses the data cube by applying a series of operations.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class DataCube(ee.ImageCollection):\n    \"\"\"\n    A class representing a data cube in Google Earth Engine.\n\n    This class extends the `ee.ImageCollection` class and provides additional methods for processing and manipulating the data cube.\n\n    Attributes:\n        BANDS (list): A list of spectral bands in the data cube.\n\n    Methods:\n        select_spectral_bands: Selects the spectral bands based on a pattern.\n        rename_bands: Renames the spectral bands in the data cube.\n        preproces: Preprocesses the data cube by applying a series of operations.\n\n    \"\"\"\n\n    BANDS = [\"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B11\", \"B12\"]\n\n    def __init__(self, args: Any):\n        super().__init__(args)\n\n    def select_spectral_bands(self) -&gt; DataCube:\n        \"\"\"\n        Selects the spectral bands based on a pattern.\n\n        Returns:\n            DataCube: A new data cube with the selected spectral bands.\n        \"\"\"\n        pattern = \"a_spri_b0[2-9].*|a_spri_b[1-2].*|b_summ_b0[2-9].*|b_summ_b[1-2].*|c_fall_b0[2-9].*|c_fall_b[1-2].*\"\n        return self.select(pattern)\n\n    def rename_bands(self) -&gt; DataCube:\n        \"\"\"\n        Renames the spectral bands in the data cube.\n\n        Returns:\n            DataCube: A new data cube with the renamed bands.\n        \"\"\"\n        spring_bands = self.BANDS\n        summer_bands = [f'{_}_1' for _ in self.BANDS]\n        fall_bands = [f'{_}_2' for _ in self.BANDS]\n\n        new_names = spring_bands + summer_bands + fall_bands\n        return self.select(self.first().bandNames(), new_names)\n\n    def preprocess(self, aoi: ee.Geometry) -&gt; DataCube:\n        return self.filterBounds(aoi).select_spectral_bands().rename_bands()\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.DataCube.rename_bands","title":"<code>rename_bands(self)</code>","text":"<p>Renames the spectral bands in the data cube.</p> <p>Returns:</p> Type Description <code>DataCube</code> <p>A new data cube with the renamed bands.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def rename_bands(self) -&gt; DataCube:\n    \"\"\"\n    Renames the spectral bands in the data cube.\n\n    Returns:\n        DataCube: A new data cube with the renamed bands.\n    \"\"\"\n    spring_bands = self.BANDS\n    summer_bands = [f'{_}_1' for _ in self.BANDS]\n    fall_bands = [f'{_}_2' for _ in self.BANDS]\n\n    new_names = spring_bands + summer_bands + fall_bands\n    return self.select(self.first().bandNames(), new_names)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.DataCube.select_spectral_bands","title":"<code>select_spectral_bands(self)</code>","text":"<p>Selects the spectral bands based on a pattern.</p> <p>Returns:</p> Type Description <code>DataCube</code> <p>A new data cube with the selected spectral bands.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def select_spectral_bands(self) -&gt; DataCube:\n    \"\"\"\n    Selects the spectral bands based on a pattern.\n\n    Returns:\n        DataCube: A new data cube with the selected spectral bands.\n    \"\"\"\n    pattern = \"a_spri_b0[2-9].*|a_spri_b[1-2].*|b_summ_b0[2-9].*|b_summ_b[1-2].*|c_fall_b0[2-9].*|c_fall_b[1-2].*\"\n    return self.select(pattern)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ErrorMatrix","title":"<code> ErrorMatrix        </code>","text":"<p>Represents an error matrix for evaluating classification accuracy.</p> <p>Parameters:</p> Name Type Description Default <code>predicted</code> <code>ee.FeatureCollection</code> <p>The predicted feature collection.</p> required <code>label_col</code> <code>str</code> <p>The name of the label column.</p> required <code>order</code> <code>list[str] | ee.List</code> <p>The order of classes in the matrix. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the error matrix. Defaults to None.</p> <code>None</code> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class ErrorMatrix:\n    \"\"\"\n    Represents an error matrix for evaluating classification accuracy.\n\n    Args:\n        predicted (ee.FeatureCollection): The predicted feature collection.\n        label_col (str): The name of the label column.\n        order (list[str] | ee.List, optional): The order of classes in the matrix. Defaults to None.\n        name (str, optional): The name of the error matrix. Defaults to None.\n    \"\"\"\n\n    def __init__(self, predicted: ee.FeatureCollection, label_col: str, order: list[str] | ee.List = None, name: str = None) -&gt; None:\n        self.matrix = self._mk_error_matrix(\n            predicted=predicted,\n            label_col=label_col,\n            order=order,\n            name=name\n        )\n\n    @property\n    def error_matrix(self) -&gt; ee.Array:\n        \"\"\"\n        Get the error matrix as an ee.Array.\n\n        Returns:\n            ee.Array: The error matrix.\n        \"\"\"\n        return self.matrix.array()\n\n    @property\n    def accuracy(self) -&gt; ee.Number:\n        \"\"\"\n        Get the overall accuracy of the error matrix.\n\n        Returns:\n            ee.Number: The overall accuracy.\n        \"\"\"\n        return self.matrix.accuracy()\n\n    @property\n    def producers_accuracy(self) -&gt; ee.List:\n        \"\"\"\n        Get the producer's accuracy for each class.\n\n        Returns:\n            ee.List: The producer's accuracy for each class.\n        \"\"\"\n        return self.matrix.producersAccuracy().toList().flatten()\n\n    @property\n    def consumers_accuracy(self) -&gt; ee.List:\n        \"\"\"\n        Get the consumer's accuracy for each class.\n\n        Returns:\n            ee.List: The consumer's accuracy for each class.\n        \"\"\"\n        return self.matrix.consumersAccuracy().toList().flatten()\n\n    @property\n    def order(self) -&gt; ee.List:\n        \"\"\"\n        Get the order of classes in the error matrix.\n\n        Returns:\n            ee.List: The order of classes.\n        \"\"\"\n        return self.matrix.order()\n\n    @staticmethod\n    def _mk_error_matrix(predicted, label_col, name, order):\n        \"\"\"\n        Create an error matrix.\n\n        Args:\n            predicted (ee.FeatureCollection): The predicted feature collection.\n            label_col (str): The name of the label column.\n            name (str): The name of the error matrix.\n            order (list[str] | ee.List): The order of classes in the matrix.\n\n        Returns:\n            ee.ConfusionMatrix: The error matrix.\n        \"\"\"\n        return predicted.errorMatrix(label_col, name, order = order)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ErrorMatrix.accuracy","title":"<code>accuracy: ee.Number</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the overall accuracy of the error matrix.</p> <p>Returns:</p> Type Description <code>ee.Number</code> <p>The overall accuracy.</p>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ErrorMatrix.consumers_accuracy","title":"<code>consumers_accuracy: ee.List</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the consumer's accuracy for each class.</p> <p>Returns:</p> Type Description <code>ee.List</code> <p>The consumer's accuracy for each class.</p>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ErrorMatrix.error_matrix","title":"<code>error_matrix: ee.Array</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the error matrix as an ee.Array.</p> <p>Returns:</p> Type Description <code>ee.Array</code> <p>The error matrix.</p>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ErrorMatrix.order","title":"<code>order: ee.List</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the order of classes in the error matrix.</p> <p>Returns:</p> Type Description <code>ee.List</code> <p>The order of classes.</p>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ErrorMatrix.producers_accuracy","title":"<code>producers_accuracy: ee.List</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the producer's accuracy for each class.</p> <p>Returns:</p> Type Description <code>ee.List</code> <p>The producer's accuracy for each class.</p>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Features","title":"<code> Features        </code>","text":"<p>A class representing a collection of features in Google Earth Engine.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class Features:\n    \"\"\"\n    A class representing a collection of features in Google Earth Engine.\n    \"\"\"\n\n    def __init__(self, args: Any):\n        self.dataset = args\n\n    @property\n    def dataset(self):\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, args: Any):\n        if isinstance(self, ee.FeatureCollection):\n            self._dataset = args\n        else:\n            self._dataset = ee.FeatureCollection(args)\n\n    def extract(self, image: ee.Image, **kwargs) -&gt; Features:\n        \"\"\"\n        Extracts the features from the given image and updates the dataset.\n\n        Args:\n            image (ee.Image): The image to extract features from.\n            **kwargs: Additional keyword arguments to be passed to the `sampleRegions` method.\n\n        Returns:\n            Features: The updated Features object.\n        \"\"\"\n        self._dataset = image.sampleRegions(collection=self._dataset, **kwargs)\n        return self\n\n    def get_lables(self, label_col: str) -&gt; ee.List:\n        \"\"\"\n        Retrieves the unique labels from the specified label column.\n\n        Args:\n            label_col (str): The name of the label column.\n\n        Returns:\n            ee.List: A list of unique labels.\n        \"\"\"\n        return self._dataset.aggregate_array(label_col).distinct()\n\n    def get_split(self, meta_flag: str, value: str | int) -&gt; Features:\n        \"\"\"\n        Filters the dataset based on the specified metadata flag and value.\n\n        Args:\n            meta_flag (str): The name of the metadata flag.\n            value (str | int): The value to filter on.\n\n        Returns:\n            Features: A new Features object with the filtered dataset.\n        \"\"\"\n        return Features(self._dataset.filter(ee.Filter.eq(meta_flag, value)))\n\n    def export_to_asset(self, dest: str, start: bool = True) -&gt; ee.batch.Task:\n        \"\"\"\n        Exports the dataset to a Google Earth Engine asset.\n\n        Args:\n            dest (str): The destination asset ID.\n            start (bool, optional): Whether to start the export task immediately. Defaults to True.\n\n        Returns:\n            ee.batch.Task: The export task.\n        \"\"\"\n        task = ee.batch.Export.table.toAsset(self._dataset, description=\"\", assetId=dest)\n        if start:\n            task.start()\n        return task\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Features.export_to_asset","title":"<code>export_to_asset(self, dest, start=True)</code>","text":"<p>Exports the dataset to a Google Earth Engine asset.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>str</code> <p>The destination asset ID.</p> required <code>start</code> <code>bool</code> <p>Whether to start the export task immediately. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.batch.Task</code> <p>The export task.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def export_to_asset(self, dest: str, start: bool = True) -&gt; ee.batch.Task:\n    \"\"\"\n    Exports the dataset to a Google Earth Engine asset.\n\n    Args:\n        dest (str): The destination asset ID.\n        start (bool, optional): Whether to start the export task immediately. Defaults to True.\n\n    Returns:\n        ee.batch.Task: The export task.\n    \"\"\"\n    task = ee.batch.Export.table.toAsset(self._dataset, description=\"\", assetId=dest)\n    if start:\n        task.start()\n    return task\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Features.extract","title":"<code>extract(self, image, **kwargs)</code>","text":"<p>Extracts the features from the given image and updates the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The image to extract features from.</p> required <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>sampleRegions</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Features</code> <p>The updated Features object.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def extract(self, image: ee.Image, **kwargs) -&gt; Features:\n    \"\"\"\n    Extracts the features from the given image and updates the dataset.\n\n    Args:\n        image (ee.Image): The image to extract features from.\n        **kwargs: Additional keyword arguments to be passed to the `sampleRegions` method.\n\n    Returns:\n        Features: The updated Features object.\n    \"\"\"\n    self._dataset = image.sampleRegions(collection=self._dataset, **kwargs)\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Features.get_lables","title":"<code>get_lables(self, label_col)</code>","text":"<p>Retrieves the unique labels from the specified label column.</p> <p>Parameters:</p> Name Type Description Default <code>label_col</code> <code>str</code> <p>The name of the label column.</p> required <p>Returns:</p> Type Description <code>ee.List</code> <p>A list of unique labels.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def get_lables(self, label_col: str) -&gt; ee.List:\n    \"\"\"\n    Retrieves the unique labels from the specified label column.\n\n    Args:\n        label_col (str): The name of the label column.\n\n    Returns:\n        ee.List: A list of unique labels.\n    \"\"\"\n    return self._dataset.aggregate_array(label_col).distinct()\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Features.get_split","title":"<code>get_split(self, meta_flag, value)</code>","text":"<p>Filters the dataset based on the specified metadata flag and value.</p> <p>Parameters:</p> Name Type Description Default <code>meta_flag</code> <code>str</code> <p>The name of the metadata flag.</p> required <code>value</code> <code>str | int</code> <p>The value to filter on.</p> required <p>Returns:</p> Type Description <code>Features</code> <p>A new Features object with the filtered dataset.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def get_split(self, meta_flag: str, value: str | int) -&gt; Features:\n    \"\"\"\n    Filters the dataset based on the specified metadata flag and value.\n\n    Args:\n        meta_flag (str): The name of the metadata flag.\n        value (str | int): The value to filter on.\n\n    Returns:\n        Features: A new Features object with the filtered dataset.\n    \"\"\"\n    return Features(self._dataset.filter(ee.Filter.eq(meta_flag, value)))\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries","title":"<code> HarmonicTimeSeries        </code>","text":"<p>Represents a harmonic time series analysis on an Earth Engine ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>ee.ImageCollection</code> <p>The Earth Engine ImageCollection to perform the analysis on.</p> required <code>dependent</code> <code>str</code> <p>The name of the dependent variable.</p> required <code>modes</code> <code>int</code> <p>The number of harmonic modes to include. Defaults to 3.</p> <code>3</code> <p>Attributes:</p> Name Type Description <code>dataset</code> <code>ee.ImageCollection</code> <p>The Earth Engine ImageCollection used for the analysis.</p> <code>independent</code> <code>list[str]</code> <p>The list of independent variable names.</p> <code>dependent</code> <code>str</code> <p>The name of the dependent variable.</p> <code>modes</code> <code>int</code> <p>The number of harmonic modes to include.</p> <code>trend</code> <code>ee.Image | None</code> <p>The computed trend image.</p> <code>coef</code> <code>list[str] | None</code> <p>The list of harmonic coefficient variable names.</p> <p>Methods</p> <p>add_constant(): Adds a constant variable to the dataset. add_time(): Adds a time variable to the dataset. add_harmonics(): Adds harmonic variables to the dataset. set_harmonic_trend(): Computes the trend image using the independent and dependent variables. add_harmonic_coefficients(): Adds harmonic coefficient variables to the dataset. add_phase(): Adds phase variables to the dataset. add_amplitude(): Adds amplitude variables to the dataset. build() -&gt; ee.ImageCollection: Returns the modified dataset. transform() -&gt; ee.Image: Transforms the dataset into a single image. get_sin_cos_selectors() -&gt; tuple[list[str], list[str]]: Returns the selectors for sin and cos variables.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class HarmonicTimeSeries:\n    \"\"\"\n    Represents a harmonic time series analysis on an Earth Engine ImageCollection.\n\n    Args:\n        dataset (ee.ImageCollection): The Earth Engine ImageCollection to perform the analysis on.\n        dependent (str): The name of the dependent variable.\n        modes (int, optional): The number of harmonic modes to include. Defaults to 3.\n\n    Attributes:\n        dataset (ee.ImageCollection): The Earth Engine ImageCollection used for the analysis.\n        independent (list[str]): The list of independent variable names.\n        dependent (str): The name of the dependent variable.\n        modes (int): The number of harmonic modes to include.\n        trend (ee.Image | None): The computed trend image.\n        coef (list[str] | None): The list of harmonic coefficient variable names.\n\n    Methods:\n        add_constant(): Adds a constant variable to the dataset.\n        add_time(): Adds a time variable to the dataset.\n        add_harmonics(): Adds harmonic variables to the dataset.\n        set_harmonic_trend(): Computes the trend image using the independent and dependent variables.\n        add_harmonic_coefficients(): Adds harmonic coefficient variables to the dataset.\n        add_phase(): Adds phase variables to the dataset.\n        add_amplitude(): Adds amplitude variables to the dataset.\n        build() -&gt; ee.ImageCollection: Returns the modified dataset.\n        transform() -&gt; ee.Image: Transforms the dataset into a single image.\n        get_sin_cos_selectors() -&gt; tuple[list[str], list[str]]: Returns the selectors for sin and cos variables.\n    \"\"\"\n\n    def __init__(self, dataset: ee.ImageCollection, dependent: str, modes: int = 3) -&gt; None:\n        \"\"\"\n        Initialize the HarmonicTimeSeries object.\n\n        Args:\n            dataset (ee.ImageCollection): The Earth Engine Image Collection.\n            dependent (str): The dependent variable.\n            modes (int, optional): The number of modes to compute. Defaults to 3.\n        \"\"\"\n        self.dataset = dataset\n        self.independent = []\n        self.dependent = dependent\n        self.modes = modes\n        self.trend = None\n        self.coef: list[str] | None = None\n\n    def add_constant(self):\n        \"\"\"\n        Adds a constant column to the dataset and updates the list of independent variables.\n\n        Returns:\n            self: The updated instance of the class.\n        \"\"\"\n        self.dataset = self.dataset.map(add_constant)\n        self.independent.append('constant')\n        return self\n\n    def add_time(self) -&gt; HarmonicTimeSeries:\n        \"\"\"\n        Adds a time dimension to the dataset and updates the list of independent variables.\n\n        Returns:\n            HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n        \"\"\"\n        self.dataset = self.dataset.map(add_time)\n        self.independent.append('t')\n        return self\n\n    def add_harmonics(self) -&gt; HarmonicTimeSeries:\n        \"\"\"\n        Adds harmonics to the dataset.\n\n        Returns:\n            HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n        \"\"\"\n        freqs = list(range(1, self.modes + 1))\n        cos_names = [f'cos_{_}' for _ in freqs]\n        sin_names = [f'sin_{_}' for _ in freqs]\n        self.dataset = self.dataset.map(add_harmonics(freqs=freqs, cos_names=cos_names, sin_names=sin_names))\n        self.independent.extend(cos_names)\n        self.independent.extend(sin_names)\n        return self\n\n    def set_harmonic_trend(self) -&gt; HarmonicTimeSeries:\n        \"\"\"\n        Computes the harmonic trend of the dataset using the provided independent and dependent variables.\n\n        Returns:\n            HarmonicTimeSeries: The computed harmonic trend.\n        \"\"\"\n        self.trend = compute_trend(self.dataset, self.independent, self.dependent)\n        return self\n\n    def add_harmonic_coefficients(self) -&gt; HarmonicTimeSeries:\n        \"\"\"\n        Adds harmonic trend coefficients to the dataset.\n\n        Returns:\n            HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n        \"\"\"\n        selectors = [f\"{_}_coef\" for _ in self.independent] + [self.dependent]\n        coef = compute_harmonic_trend_coefficients(self.trend, self.independent)\n        self.dataset = self.dataset.map(lambda x: x.addBands(coef)).select(selectors)\n        self.coef = selectors\n        return self\n\n    def add_phase(self) -&gt; HarmonicTimeSeries:\n        \"\"\"\n        Adds phase information to the dataset by applying sine and cosine functions.\n\n        Returns:\n            HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n        \"\"\"\n        for cos, sin in self.get_sin_cos_selectors():\n            self.dataset = self.dataset.map(add_phase(cos, sin))\n        return self\n\n    def add_amplitue(self) -&gt; HarmonicTimeSeries:\n        \"\"\"\n        Adds the amplitude of harmonic components to the dataset.\n\n        Returns:\n            HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n        \"\"\"\n        for cos, sin in self.get_sin_cos_selectors():\n            self.dataset = self.dataset.map(add_amplitude(cos, sin))\n        return self\n\n    def build(self) -&gt; ee.ImageCollection:\n        \"\"\"\n        Builds and returns the image collection.\n\n        Returns:\n            ee.ImageCollection: The built image collection.\n        \"\"\"\n        return self.dataset\n\n    def transform(self) -&gt; ee.Image:\n        \"\"\"\n        Transforms the dataset into an Earth Engine Image.\n\n        Returns:\n            ee.Image: The transformed Earth Engine Image.\n        \"\"\"\n        return transform(self.dataset)\n\n    def get_sin_cos_selectors(self) -&gt; tuple[list[str], list[str]]:\n        \"\"\"\n        Returns a tuple of two lists containing the 'cos' and 'sin' selectors from the 'coef' list.\n\n        Returns:\n            A tuple containing two lists:\n            - The first list contains the selectors from 'coef' that contain the substring 'cos'.\n            - The second list contains the selectors from 'coef' that contain the substring 'sin'.\n        \"\"\"\n        return zip(\n            [_ for _ in self.coef if 'cos' in _],\n            [_ for _ in self.coef if 'sin' in _]\n        )\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.__init__","title":"<code>__init__(self, dataset, dependent, modes=3)</code>  <code>special</code>","text":"<p>Initialize the HarmonicTimeSeries object.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>ee.ImageCollection</code> <p>The Earth Engine Image Collection.</p> required <code>dependent</code> <code>str</code> <p>The dependent variable.</p> required <code>modes</code> <code>int</code> <p>The number of modes to compute. Defaults to 3.</p> <code>3</code> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def __init__(self, dataset: ee.ImageCollection, dependent: str, modes: int = 3) -&gt; None:\n    \"\"\"\n    Initialize the HarmonicTimeSeries object.\n\n    Args:\n        dataset (ee.ImageCollection): The Earth Engine Image Collection.\n        dependent (str): The dependent variable.\n        modes (int, optional): The number of modes to compute. Defaults to 3.\n    \"\"\"\n    self.dataset = dataset\n    self.independent = []\n    self.dependent = dependent\n    self.modes = modes\n    self.trend = None\n    self.coef: list[str] | None = None\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.add_amplitue","title":"<code>add_amplitue(self)</code>","text":"<p>Adds the amplitude of harmonic components to the dataset.</p> <p>Returns:</p> Type Description <code>HarmonicTimeSeries</code> <p>The updated HarmonicTimeSeries object.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_amplitue(self) -&gt; HarmonicTimeSeries:\n    \"\"\"\n    Adds the amplitude of harmonic components to the dataset.\n\n    Returns:\n        HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n    \"\"\"\n    for cos, sin in self.get_sin_cos_selectors():\n        self.dataset = self.dataset.map(add_amplitude(cos, sin))\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.add_constant","title":"<code>add_constant(self)</code>","text":"<p>Adds a constant column to the dataset and updates the list of independent variables.</p> <p>Returns:</p> Type Description <code>self</code> <p>The updated instance of the class.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_constant(self):\n    \"\"\"\n    Adds a constant column to the dataset and updates the list of independent variables.\n\n    Returns:\n        self: The updated instance of the class.\n    \"\"\"\n    self.dataset = self.dataset.map(add_constant)\n    self.independent.append('constant')\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.add_harmonic_coefficients","title":"<code>add_harmonic_coefficients(self)</code>","text":"<p>Adds harmonic trend coefficients to the dataset.</p> <p>Returns:</p> Type Description <code>HarmonicTimeSeries</code> <p>The updated HarmonicTimeSeries object.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_harmonic_coefficients(self) -&gt; HarmonicTimeSeries:\n    \"\"\"\n    Adds harmonic trend coefficients to the dataset.\n\n    Returns:\n        HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n    \"\"\"\n    selectors = [f\"{_}_coef\" for _ in self.independent] + [self.dependent]\n    coef = compute_harmonic_trend_coefficients(self.trend, self.independent)\n    self.dataset = self.dataset.map(lambda x: x.addBands(coef)).select(selectors)\n    self.coef = selectors\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.add_harmonics","title":"<code>add_harmonics(self)</code>","text":"<p>Adds harmonics to the dataset.</p> <p>Returns:</p> Type Description <code>HarmonicTimeSeries</code> <p>The updated HarmonicTimeSeries object.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_harmonics(self) -&gt; HarmonicTimeSeries:\n    \"\"\"\n    Adds harmonics to the dataset.\n\n    Returns:\n        HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n    \"\"\"\n    freqs = list(range(1, self.modes + 1))\n    cos_names = [f'cos_{_}' for _ in freqs]\n    sin_names = [f'sin_{_}' for _ in freqs]\n    self.dataset = self.dataset.map(add_harmonics(freqs=freqs, cos_names=cos_names, sin_names=sin_names))\n    self.independent.extend(cos_names)\n    self.independent.extend(sin_names)\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.add_phase","title":"<code>add_phase(self)</code>","text":"<p>Adds phase information to the dataset by applying sine and cosine functions.</p> <p>Returns:</p> Type Description <code>HarmonicTimeSeries</code> <p>The updated HarmonicTimeSeries object.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_phase(self) -&gt; HarmonicTimeSeries:\n    \"\"\"\n    Adds phase information to the dataset by applying sine and cosine functions.\n\n    Returns:\n        HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n    \"\"\"\n    for cos, sin in self.get_sin_cos_selectors():\n        self.dataset = self.dataset.map(add_phase(cos, sin))\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.add_time","title":"<code>add_time(self)</code>","text":"<p>Adds a time dimension to the dataset and updates the list of independent variables.</p> <p>Returns:</p> Type Description <code>HarmonicTimeSeries</code> <p>The updated HarmonicTimeSeries object.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_time(self) -&gt; HarmonicTimeSeries:\n    \"\"\"\n    Adds a time dimension to the dataset and updates the list of independent variables.\n\n    Returns:\n        HarmonicTimeSeries: The updated HarmonicTimeSeries object.\n    \"\"\"\n    self.dataset = self.dataset.map(add_time)\n    self.independent.append('t')\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.build","title":"<code>build(self)</code>","text":"<p>Builds and returns the image collection.</p> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>The built image collection.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def build(self) -&gt; ee.ImageCollection:\n    \"\"\"\n    Builds and returns the image collection.\n\n    Returns:\n        ee.ImageCollection: The built image collection.\n    \"\"\"\n    return self.dataset\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.get_sin_cos_selectors","title":"<code>get_sin_cos_selectors(self)</code>","text":"<p>Returns a tuple of two lists containing the 'cos' and 'sin' selectors from the 'coef' list.</p> <p>Returns:</p> Type Description <code>A tuple containing two lists</code> <ul> <li>The first list contains the selectors from 'coef' that contain the substring 'cos'.</li> <li>The second list contains the selectors from 'coef' that contain the substring 'sin'.</li> </ul> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def get_sin_cos_selectors(self) -&gt; tuple[list[str], list[str]]:\n    \"\"\"\n    Returns a tuple of two lists containing the 'cos' and 'sin' selectors from the 'coef' list.\n\n    Returns:\n        A tuple containing two lists:\n        - The first list contains the selectors from 'coef' that contain the substring 'cos'.\n        - The second list contains the selectors from 'coef' that contain the substring 'sin'.\n    \"\"\"\n    return zip(\n        [_ for _ in self.coef if 'cos' in _],\n        [_ for _ in self.coef if 'sin' in _]\n    )\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.set_harmonic_trend","title":"<code>set_harmonic_trend(self)</code>","text":"<p>Computes the harmonic trend of the dataset using the provided independent and dependent variables.</p> <p>Returns:</p> Type Description <code>HarmonicTimeSeries</code> <p>The computed harmonic trend.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def set_harmonic_trend(self) -&gt; HarmonicTimeSeries:\n    \"\"\"\n    Computes the harmonic trend of the dataset using the provided independent and dependent variables.\n\n    Returns:\n        HarmonicTimeSeries: The computed harmonic trend.\n    \"\"\"\n    self.trend = compute_trend(self.dataset, self.independent, self.dependent)\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.HarmonicTimeSeries.transform","title":"<code>transform(self)</code>","text":"<p>Transforms the dataset into an Earth Engine Image.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The transformed Earth Engine Image.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def transform(self) -&gt; ee.Image:\n    \"\"\"\n    Transforms the dataset into an Earth Engine Image.\n\n    Returns:\n        ee.Image: The transformed Earth Engine Image.\n    \"\"\"\n    return transform(self.dataset)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ImageStack","title":"<code> ImageStack        </code>","text":"<p>A class representing a stack of images in Google Earth Engine.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class ImageStack:\n    \"\"\"\n    A class representing a stack of images in Google Earth Engine.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.dataset = []\n\n    def add(self, image: ee.Iamge) -&gt; ImageStack:\n        \"\"\"\n        Adds an image to the stack.\n\n        Args:\n            image (ee.Image): The image to add to the stack.\n\n        Returns:\n            ImageStack: The updated ImageStack object.\n        \"\"\"\n        self.dataset.append(image)\n        return self\n\n    def build(self) -&gt; ee.Image:\n        \"\"\"\n        Builds and returns the stacked image.\n\n        Returns:\n            ee.Image: The stacked image.\n        \"\"\"\n        return ee.Image.cat(*self.dataset)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ImageStack.add","title":"<code>add(self, image)</code>","text":"<p>Adds an image to the stack.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The image to add to the stack.</p> required <p>Returns:</p> Type Description <code>ImageStack</code> <p>The updated ImageStack object.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add(self, image: ee.Iamge) -&gt; ImageStack:\n    \"\"\"\n    Adds an image to the stack.\n\n    Args:\n        image (ee.Image): The image to add to the stack.\n\n    Returns:\n        ImageStack: The updated ImageStack object.\n    \"\"\"\n    self.dataset.append(image)\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.ImageStack.build","title":"<code>build(self)</code>","text":"<p>Builds and returns the stacked image.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The stacked image.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def build(self) -&gt; ee.Image:\n    \"\"\"\n    Builds and returns the stacked image.\n\n    Returns:\n        ee.Image: The stacked image.\n    \"\"\"\n    return ee.Image.cat(*self.dataset)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Sentinel1","title":"<code> Sentinel1            (ImageCollection)         </code>","text":"<p>A class representing the Sentinel-1 image collection in Google Earth Engine.</p> <p>This class extends the <code>ee.ImageCollection</code> class and provides additional methods for preprocessing and filtering Sentinel-1 images.</p> <p>Methods</p> <p>preprocess: Preprocesses the Sentinel-1 image collection based on the given parameters. add_dv_filter: Adds a dual-polarization filter to the Sentinel-1 image collection.</p> <p>Usage</p> <p>sentinel1 = Sentinel1() preprocessed_collection = sentinel1.preprocess(aoi, start, end, look_dir='DESCENDING') filtered_collection = sentinel1.add_dv_filter()</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class Sentinel1(ee.ImageCollection):\n    \"\"\"\n    A class representing the Sentinel-1 image collection in Google Earth Engine.\n\n    This class extends the `ee.ImageCollection` class and provides additional methods for preprocessing and filtering\n    Sentinel-1 images.\n\n    Attributes:\n        None\n\n    Methods:\n        preprocess: Preprocesses the Sentinel-1 image collection based on the given parameters.\n        add_dv_filter: Adds a dual-polarization filter to the Sentinel-1 image collection.\n\n    Usage:\n        sentinel1 = Sentinel1()\n        preprocessed_collection = sentinel1.preprocess(aoi, start, end, look_dir='DESCENDING')\n        filtered_collection = sentinel1.add_dv_filter()\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"COPERNICUS/S1_GRD\")\n\n    def apply_dv_filter(self) -&gt; Sentinel1:\n        return (self.filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\n                .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH')))\n\n    def apply_iw_mode_filter(self) -&gt; Sentinel1:\n        return self.filter(ee.Filter.eq('instrumentMode', 'IW'))\n\n    def apply_acs_filter(self) -&gt; Sentinel1:\n        return self.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))\n\n    def apply_desc_filter(self) -&gt; Sentinel1:\n        return self.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))\n\n    def get_orbit_numbers(self) -&gt; ee.List:\n        return self.aggregate_array('relativeOrbitNumber_start').distinct()\n\n    def select(self, args: Any = None) -&gt; Sentinel1:\n        if args is None:\n            return super().select('V.*')\n        return super().select(args)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Sentinel1.select","title":"<code>select(self, args=None)</code>","text":"<p>Select bands from each image in a collection.</p> <p>Parameters:</p> Name Type Description Default <code>selectors</code> <p>An array of names, regexes or numeric indices specifying the bands to select.</p> required <code>names</code> <p>An array of strings specifying the new names for the selected bands.  If supplied, the length must match the number of bands selected.</p> required <code>*args</code> <code>Any</code> <p>Selector elements as varargs.</p> <code>None</code> <p>Returns:</p> Type Description <code>Sentinel1</code> <p>The image collection with selected bands.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def select(self, args: Any = None) -&gt; Sentinel1:\n    if args is None:\n        return super().select('V.*')\n    return super().select(args)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Sentinel2TOA","title":"<code> Sentinel2TOA            (ImageCollection)         </code>","text":"<p>A class representing the Sentinel-2 Top of Atmosphere (TOA) image collection in Google Earth Engine.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class Sentinel2TOA(ee.ImageCollection):\n    \"\"\"\n    A class representing the Sentinel-2 Top of Atmosphere (TOA) image collection in Google Earth Engine.\n    \"\"\"\n\n    BANDS = [\"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B11\", \"B12\"]\n\n    def __init__(self):\n        super().__init__(\"COPERNICUS/S2_HARMONIZED\")\n\n    def apply_cloud_percent_filer(self, percent: float = 20.0) -&gt; Sentinel2TOA:\n        return self.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', percent))\n\n    def apply_cloud_mask(self):\n\n        def mask_clouds(img: ee.Image) -&gt; ee.Image:\n            \"\"\"\n            Masks clouds and cirrus in a Sentinel-2 TOA image.\n\n            Args:\n                img: The Sentinel-2 TOA image.\n\n            Returns:\n                The masked Sentinel-2 TOA image.\n            \"\"\"\n            qa = img.select('QA60')\n\n            # Bits 10 and 11 are clouds and cirrus, respectively.\n            cloud_bit_mask = 1 &lt;&lt; 10\n            cirrus_bit_mask = 1 &lt;&lt; 11\n\n            # Both flags should be set to zero, indicating clear conditions.\n            mask = (\n                qa.bitwiseAnd(cloud_bit_mask)\n                .eq(0)\n                .And(qa.bitwiseAnd(cirrus_bit_mask).eq(0))\n            )\n\n            return img.updateMask(mask)\n        return self.map(mask_clouds)\n\n    def select(self, args: Any = None):\n        if args is None:\n            return super().select(self.BANDS)\n        return super().select(args)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.Sentinel2TOA.select","title":"<code>select(self, args=None)</code>","text":"<p>Select bands from each image in a collection.</p> <p>Parameters:</p> Name Type Description Default <code>selectors</code> <p>An array of names, regexes or numeric indices specifying the bands to select.</p> required <code>names</code> <p>An array of strings specifying the new names for the selected bands.  If supplied, the length must match the number of bands selected.</p> required <code>*args</code> <code>Any</code> <p>Selector elements as varargs.</p> <code>None</code> <p>Returns:</p> Type Description <p>The image collection with selected bands.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def select(self, args: Any = None):\n    if args is None:\n        return super().select(self.BANDS)\n    return super().select(args)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.SmileRandomForest","title":"<code> SmileRandomForest        </code>","text":"<p>A class representing a Random Forest classifier implemented in Google Earth Engine (GEE).</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>class SmileRandomForest:\n    \"\"\"\n    A class representing a Random Forest classifier implemented in Google Earth Engine (GEE).\n    \"\"\"\n\n    def __init__(self, ntrees: int = 1000, **kwargs) -&gt; None:\n        \"\"\"\n        Initializes a SmileRandomForest object.\n\n        Args:\n            ntrees (int, optional): The number of trees in the random forest. Defaults to 1000.\n            **kwargs: Additional keyword arguments for the random forest classifier.\n        \"\"\"\n        self.ntrees = ntrees\n        self.kwargs = kwargs  # hyper parameters\n        self.model = None\n        self.class_prop = None\n\n    @classmethod\n    def load_model(cls, asset_id: str) -&gt; SmileRandomForest:\n        \"\"\"\n        Loads a pre-trained SmileRandomForest model from a GEE asset.\n\n        Args:\n            asset_id (str): The asset ID of the pre-trained model.\n\n        Returns:\n            SmileRandomForest: An instance of the SmileRandomForest class with the loaded model.\n        \"\"\"\n        instance = cls()\n        instance.model = ee.Classifier.load(asset_id)\n        return instance\n\n    def train(self, features, class_prop, predictors):\n        \"\"\"\n        Trains the random forest classifier using the specified features, class property, and predictors.\n\n        Args:\n            features: The input features for training. Can be a Features object or a GEE dataset.\n            class_prop: The property containing the class labels.\n            predictors: The list of property names to be used as predictors.\n\n        Returns:\n            SmileRandomForest: The trained SmileRandomForest object.\n        \"\"\"\n        if isinstance(features, Features):\n            features = features.dataset\n\n        self.model = (ee.Classifier.smileRandomForest(numberOfTrees=self.ntrees, **self.kwargs)\n                      .train(features, class_prop, predictors))\n        return self\n\n    def predict(self, X: ee.Image | ee.FeatureCollection) -&gt; ee.Image | ee.FeatureCollection:\n        \"\"\"\n        Predicts the class labels for the input data using the trained random forest classifier.\n\n        Args:\n            X (ee.Image | ee.FeatureCollection): The input data to be classified.\n\n        Returns:\n            ee.Image | ee.FeatureCollection: The classified image or feature collection.\n        \"\"\"\n        if self.model is None:\n            raise ValueError('You must train the model before predicting')\n        if isinstance(X, Features):\n            X = X.dataset\n        return X.classify(self.model)\n\n    def assess(self, test: ee.FeatureCollection) -&gt; ErrorMatrix:\n        \"\"\"\n        Assesses the performance of the random forest classifier on a test dataset.\n\n        Args:\n            test (ee.FeatureCollection): The test dataset.\n\n        Returns:\n            ErrorMatrix: An ErrorMatrix object representing the classification performance.\n        \"\"\"\n        predicted = self.predict(test)\n        order = test.aggregate_array(self.class_prop).distinct()\n        return ErrorMatrix(predicted, label_col=self.class_prop, order=order)\n\n    def save(self, dest: str, start: bool = True) -&gt; ee.batch.Task:\n        \"\"\"\n        Saves the trained random forest classifier to a GEE asset.\n\n        Args:\n            dest (str): The asset ID where the model will be saved.\n            start (bool, optional): Whether to start the export task immediately. Defaults to True.\n\n        Returns:\n            ee.batch.Task: The export task.\n        \"\"\"\n        task = ee.batch.Export.classifier.toAsset(**{\n            'classifier': self.model,\n            'description': '',\n            'assetId': dest\n        })\n\n        if start:\n            task.start()\n        return task\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.SmileRandomForest.__init__","title":"<code>__init__(self, ntrees=1000, **kwargs)</code>  <code>special</code>","text":"<p>Initializes a SmileRandomForest object.</p> <p>Parameters:</p> Name Type Description Default <code>ntrees</code> <code>int</code> <p>The number of trees in the random forest. Defaults to 1000.</p> <code>1000</code> <code>**kwargs</code> <p>Additional keyword arguments for the random forest classifier.</p> <code>{}</code> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def __init__(self, ntrees: int = 1000, **kwargs) -&gt; None:\n    \"\"\"\n    Initializes a SmileRandomForest object.\n\n    Args:\n        ntrees (int, optional): The number of trees in the random forest. Defaults to 1000.\n        **kwargs: Additional keyword arguments for the random forest classifier.\n    \"\"\"\n    self.ntrees = ntrees\n    self.kwargs = kwargs  # hyper parameters\n    self.model = None\n    self.class_prop = None\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.SmileRandomForest.assess","title":"<code>assess(self, test)</code>","text":"<p>Assesses the performance of the random forest classifier on a test dataset.</p> <p>Parameters:</p> Name Type Description Default <code>test</code> <code>ee.FeatureCollection</code> <p>The test dataset.</p> required <p>Returns:</p> Type Description <code>ErrorMatrix</code> <p>An ErrorMatrix object representing the classification performance.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def assess(self, test: ee.FeatureCollection) -&gt; ErrorMatrix:\n    \"\"\"\n    Assesses the performance of the random forest classifier on a test dataset.\n\n    Args:\n        test (ee.FeatureCollection): The test dataset.\n\n    Returns:\n        ErrorMatrix: An ErrorMatrix object representing the classification performance.\n    \"\"\"\n    predicted = self.predict(test)\n    order = test.aggregate_array(self.class_prop).distinct()\n    return ErrorMatrix(predicted, label_col=self.class_prop, order=order)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.SmileRandomForest.load_model","title":"<code>load_model(asset_id)</code>  <code>classmethod</code>","text":"<p>Loads a pre-trained SmileRandomForest model from a GEE asset.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The asset ID of the pre-trained model.</p> required <p>Returns:</p> Type Description <code>SmileRandomForest</code> <p>An instance of the SmileRandomForest class with the loaded model.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>@classmethod\ndef load_model(cls, asset_id: str) -&gt; SmileRandomForest:\n    \"\"\"\n    Loads a pre-trained SmileRandomForest model from a GEE asset.\n\n    Args:\n        asset_id (str): The asset ID of the pre-trained model.\n\n    Returns:\n        SmileRandomForest: An instance of the SmileRandomForest class with the loaded model.\n    \"\"\"\n    instance = cls()\n    instance.model = ee.Classifier.load(asset_id)\n    return instance\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.SmileRandomForest.predict","title":"<code>predict(self, X)</code>","text":"<p>Predicts the class labels for the input data using the trained random forest classifier.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ee.Image | ee.FeatureCollection</code> <p>The input data to be classified.</p> required <p>Returns:</p> Type Description <code>ee.Image | ee.FeatureCollection</code> <p>The classified image or feature collection.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def predict(self, X: ee.Image | ee.FeatureCollection) -&gt; ee.Image | ee.FeatureCollection:\n    \"\"\"\n    Predicts the class labels for the input data using the trained random forest classifier.\n\n    Args:\n        X (ee.Image | ee.FeatureCollection): The input data to be classified.\n\n    Returns:\n        ee.Image | ee.FeatureCollection: The classified image or feature collection.\n    \"\"\"\n    if self.model is None:\n        raise ValueError('You must train the model before predicting')\n    if isinstance(X, Features):\n        X = X.dataset\n    return X.classify(self.model)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.SmileRandomForest.save","title":"<code>save(self, dest, start=True)</code>","text":"<p>Saves the trained random forest classifier to a GEE asset.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>str</code> <p>The asset ID where the model will be saved.</p> required <code>start</code> <code>bool</code> <p>Whether to start the export task immediately. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.batch.Task</code> <p>The export task.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def save(self, dest: str, start: bool = True) -&gt; ee.batch.Task:\n    \"\"\"\n    Saves the trained random forest classifier to a GEE asset.\n\n    Args:\n        dest (str): The asset ID where the model will be saved.\n        start (bool, optional): Whether to start the export task immediately. Defaults to True.\n\n    Returns:\n        ee.batch.Task: The export task.\n    \"\"\"\n    task = ee.batch.Export.classifier.toAsset(**{\n        'classifier': self.model,\n        'description': '',\n        'assetId': dest\n    })\n\n    if start:\n        task.start()\n    return task\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.SmileRandomForest.train","title":"<code>train(self, features, class_prop, predictors)</code>","text":"<p>Trains the random forest classifier using the specified features, class property, and predictors.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <p>The input features for training. Can be a Features object or a GEE dataset.</p> required <code>class_prop</code> <p>The property containing the class labels.</p> required <code>predictors</code> <p>The list of property names to be used as predictors.</p> required <p>Returns:</p> Type Description <code>SmileRandomForest</code> <p>The trained SmileRandomForest object.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def train(self, features, class_prop, predictors):\n    \"\"\"\n    Trains the random forest classifier using the specified features, class property, and predictors.\n\n    Args:\n        features: The input features for training. Can be a Features object or a GEE dataset.\n        class_prop: The property containing the class labels.\n        predictors: The list of property names to be used as predictors.\n\n    Returns:\n        SmileRandomForest: The trained SmileRandomForest object.\n    \"\"\"\n    if isinstance(features, Features):\n        features = features.dataset\n\n    self.model = (ee.Classifier.smileRandomForest(numberOfTrees=self.ntrees, **self.kwargs)\n                  .train(features, class_prop, predictors))\n    return self\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_amplitude","title":"<code>add_amplitude(cos, sin)</code>","text":"<p>Adds an amplitude band to an image based on the provided cosine and sine bands.</p> <p>Parameters:</p> Name Type Description Default <code>cos</code> <code>str</code> <p>The name of the cosine band.</p> required <code>sin</code> <code>str</code> <p>The name of the sine band.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A function that takes an image and adds the amplitude band to it.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_amplitude(cos: str, sin: str) -&gt; Callable:\n    \"\"\"\n    Adds an amplitude band to an image based on the provided cosine and sine bands.\n\n    Args:\n        cos (str): The name of the cosine band.\n        sin (str): The name of the sine band.\n\n    Returns:\n        Callable: A function that takes an image and adds the amplitude band to it.\n    \"\"\"\n    mode = cos.split('_')[-2]\n    name = f'amplitude_{mode}'\n    def wrapper(img: ee.Image) -&gt; ee.Image:\n        return img.addBands(img.select(cos).hypot(img.select(sin)).rename(name))\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_constant","title":"<code>add_constant(img)</code>","text":"<p>Adds a constant band with a value of 1 to the input image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The input image to which the constant band will be added.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The input image with the constant band added.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_constant(img: ee.Image) -&gt; ee.Image:\n    \"\"\"\n    Adds a constant band with a value of 1 to the input image.\n\n    Args:\n        img (ee.Image): The input image to which the constant band will be added.\n\n    Returns:\n        ee.Image: The input image with the constant band added.\n    \"\"\"\n    return img.addBands(ee.Image(1))\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_harmonics","title":"<code>add_harmonics(freqs, cos_names, sin_names)</code>","text":"<p>Adds harmonic bands to an image based on the given frequencies, cosine band names, and sine band names.</p> <p>Parameters:</p> Name Type Description Default <code>freqs</code> <code>list[int]</code> <p>A list of frequencies for the harmonic bands.</p> required <code>cos_names</code> <code>list[str]</code> <p>A list of names for the cosine bands.</p> required <code>sin_names</code> <code>list[str]</code> <p>A list of names for the sine bands.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A wrapper function that adds the harmonic bands to the input image.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_harmonics(freqs: list[int], cos_names: list[str], sin_names: list[str]) -&gt; Callable:\n    \"\"\"\n    Adds harmonic bands to an image based on the given frequencies, cosine band names, and sine band names.\n\n    Args:\n        freqs (list[int]): A list of frequencies for the harmonic bands.\n        cos_names (list[str]): A list of names for the cosine bands.\n        sin_names (list[str]): A list of names for the sine bands.\n\n    Returns:\n        Callable: A wrapper function that adds the harmonic bands to the input image.\n    \"\"\"\n    def wrapper(img):\n        frequencies = ee.Image.constant(freqs)\n        time = ee.Image(img).select('t')\n        cosines = time.multiply(frequencies).cos().rename(cos_names)\n        sines = time.multiply(frequencies).sin().rename(sin_names)\n        return img.addBands(cosines).addBands(sines)\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_ndvi","title":"<code>add_ndvi(nir, red)</code>","text":"<p>Computes the Normalized Difference Vegetation Index (NDVI) for an image.</p> <p>Parameters:</p> Name Type Description Default <code>nir</code> <code>str</code> <p>The name of the near-infrared band.</p> required <code>red</code> <code>str</code> <p>The name of the red band.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A function that takes an ee.Image as input and returns an ee.Image with the NDVI band added.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_ndvi(nir: str, red: str) -&gt; Callable:\n    \"\"\"\n    Computes the Normalized Difference Vegetation Index (NDVI) for an image.\n\n    Args:\n        nir (str): The name of the near-infrared band.\n        red (str): The name of the red band.\n\n    Returns:\n        Callable: A function that takes an ee.Image as input and returns an ee.Image with the NDVI band added.\n    \"\"\"\n    def wrapper(img: ee.Image) -&gt; ee.Image:\n        return img.addBands(img.normalizedDifference([nir, red]).rename('NDVI'))\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_phase","title":"<code>add_phase(cos, sin)</code>","text":"<p>Adds a phase band to an image based on the provided cosine and sine bands.</p> <p>Parameters:</p> Name Type Description Default <code>cos</code> <code>str</code> <p>The name of the cosine band.</p> required <code>sin</code> <code>str</code> <p>The name of the sine band.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A function that takes an ee.Image as input and returns an ee.Image with the phase band added.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_phase(cos: str, sin: str) -&gt; Callable:\n    \"\"\"\n    Adds a phase band to an image based on the provided cosine and sine bands.\n\n    Args:\n        cos (str): The name of the cosine band.\n        sin (str): The name of the sine band.\n\n    Returns:\n        Callable: A function that takes an ee.Image as input and returns an ee.Image with the phase band added.\n    \"\"\"\n    mode = cos.split('_')[-2]\n    name = f'phase_{mode}'\n    def wrapper(img: ee.Image) -&gt; ee.Image:\n        return img.addBands(img.select(cos).atan2(img.select(sin)).rename(name))\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_ratio","title":"<code>add_ratio(numerator, denominator)</code>","text":"<p>Adds a ratio band to an image.</p> <p>Parameters:</p> Name Type Description Default <code>numerator</code> <code>str</code> <p>The name of the numerator band.</p> required <code>denominator</code> <code>str</code> <p>The name of the denominator band.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A function that takes an ee.Image as input and returns an ee.Image with the ratio band added.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_ratio(numerator: str, denominator: str) -&gt; Callable:\n    \"\"\"\n    Adds a ratio band to an image.\n\n    Args:\n        numerator (str): The name of the numerator band.\n        denominator (str): The name of the denominator band.\n\n    Returns:\n        Callable: A function that takes an ee.Image as input and returns an ee.Image with the ratio band added.\n    \"\"\"\n    name = f\"{numerator}_{denominator}\"\n    def wrapper(img: ee.Image) -&gt; ee.Image:\n        return img.addBands(img.select(numerator).divide(img.select(denominator)).rename(name))\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_savi","title":"<code>add_savi(nir, red, l=0.5)</code>","text":"<p>Computes the Soil Adjusted Vegetation Index (SAVI) for an image.</p> <p>Parameters:</p> Name Type Description Default <code>nir</code> <code>str</code> <p>The name of the near-infrared band.</p> required <code>red</code> <code>str</code> <p>The name of the red band.</p> required <code>l</code> <code>float</code> <p>The SAVI adjustment factor. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Callable</code> <p>A function that takes an ee.Image as input and returns the image with the SAVI band added.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_savi(nir: str, red: str, l: float = 0.5) -&gt; Callable:\n    \"\"\"\n    Computes the Soil Adjusted Vegetation Index (SAVI) for an image.\n\n    Args:\n        nir (str): The name of the near-infrared band.\n        red (str): The name of the red band.\n        l (float, optional): The SAVI adjustment factor. Defaults to 0.5.\n\n    Returns:\n        Callable: A function that takes an ee.Image as input and returns the image with the SAVI band added.\n    \"\"\"\n\n    def wrapper(img: ee.Image) -&gt; ee.Image:\n        return img.addBands(img.expression(\n            \"(1 + L) * (NIR - RED) / (NIR + RED + L)\",\n            {\n                \"NIR\": img.select(nir),\n                \"RED\": img.select(red),\n                \"L\": l,\n            },\n        ).rename('SAVI'))\n\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_tasseled_cap","title":"<code>add_tasseled_cap(*args)</code>","text":"<p>Compute the Tasseled Cap transformation for an image.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>The band names to be used in the transformation.</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable</code> <p>A wrapper function that applies the Tasseled Cap transformation to an image.</p> <p>Examples:</p> <p>tasseled_cap = compute_tasseled_cap('g', 'b', 'r', 'nir', 'swir1', 'swir2')</p> <p>transformed_image = tasseled_cap(image)</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_tasseled_cap(*args) -&gt; Callable:\n    \"\"\"\n    Compute the Tasseled Cap transformation for an image.\n\n    Args:\n        *args: The band names to be used in the transformation.\n\n    Returns:\n        A wrapper function that applies the Tasseled Cap transformation to an image.\n\n    Example:\n        tasseled_cap = compute_tasseled_cap('g', 'b', 'r', 'nir', 'swir1', 'swir2')\\n\n        transformed_image = tasseled_cap(image)\n    \"\"\"\n    g, b, r, nir, swir1, swir2 = args\n\n    def wrapper(img: ee.Image) -&gt; ee.Image:\n        tmp = img.select(g, b, r, nir, swir1, swir2)\n        co_array = [\n            [0.3037, 0.2793, 0.4743, 0.5585, 0.5082, 0.1863],\n            [-0.2848, -0.2435, -0.5436, 0.7243, 0.0840, -0.1800],\n            [0.1509, 0.1973, 0.3279, 0.3406, -0.7112, -0.4572],\n        ]\n\n        co = ee.Array(co_array)\n\n        arrayImage1D = tmp.toArray()\n        arrayImage2D = arrayImage1D.toArray(1)\n\n        components_image = (\n            ee.Image(co)\n            .matrixMultiply(arrayImage2D)\n            .arrayProject([0])\n            .arrayFlatten([[\"brightness\", \"greenness\", \"wetness\"]])\n        )\n\n        return img.addBands(components_image)\n\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.add_time","title":"<code>add_time(img)</code>","text":"<p>Adds a time band to the input image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The input image.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The input image with a time band added.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def add_time(img: ee.Image) -&gt; ee.Image:\n    \"\"\"\n    Adds a time band to the input image.\n\n    Args:\n        img (ee.Image): The input image.\n\n    Returns:\n        ee.Image: The input image with a time band added.\n    \"\"\"\n    date = img.date();\n    years = date.difference(ee.Date('1970-01-01'), 'year');\n    timeRadians = ee.Image(years.multiply(2 * pi));\n    return img.addBands(timeRadians.rename('t').float());\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.apply_boxcar","title":"<code>apply_boxcar(radius=1, **kwargs)</code>","text":"<p>Applies a boxcar filter to an image.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>The radius of the boxcar filter. Defaults to 1.</p> <code>1</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable</code> <p>A function that applies the boxcar filter to an image.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def apply_boxcar(radius: int = 1, **kwargs) -&gt; Callable:\n    \"\"\"\n    Applies a boxcar filter to an image.\n\n    Args:\n        radius (int, optional): The radius of the boxcar filter. Defaults to 1.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Callable: A function that applies the boxcar filter to an image.\n\n    \"\"\"\n    def wrapper(img: ee.Image) -&gt; ee.Image:\n        return img.convolve(ee.Kernel.square(radius, **kwargs))\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.asset_exists","title":"<code>asset_exists(asset_id)</code>","text":"<p>Check if the given asset ID exists in the assets collection.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The ID of the asset to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the asset exists, False otherwise.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def asset_exists(asset_id: str) -&gt; bool:\n    \"\"\"\n    Check if the given asset ID exists in the assets collection.\n\n    Args:\n        asset_id (str): The ID of the asset to check.\n\n    Returns:\n        bool: True if the asset exists, False otherwise.\n    \"\"\"\n    parent = \"/\".join(asset_id.split('/')[:-1])\n    assets = get_assets(parent)\n\n    if assets.empty:\n        return False\n\n    return (assets == asset_id).any().any()\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.compute_cnwi_terrain_variables","title":"<code>compute_cnwi_terrain_variables(dataset, geom)</code>","text":"<p>Computes the CNWI (Canadian Wetland Inventory) terrain variables for the given dataset and geometry.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>ee.Image</code> <p>The input image dataset.</p> required <code>geom</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The geometry or feature collection to compute the terrain variables for.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The image with the computed CNWI terrain variables.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def compute_cnwi_terrain_variables(dataset: ee.Image, geom: ee.Geometry | ee.FeatureCollection) -&gt; ee.Image:\n    \"\"\"\n    Computes the CNWI (Canadian Wetland Inventory) terrain variables for the given dataset and geometry.\n\n    Args:\n        dataset (ee.Image): The input image dataset.\n        geom (ee.Geometry | ee.FeatureCollection): The geometry or feature collection to compute the terrain variables for.\n\n    Returns:\n        ee.Image: The image with the computed CNWI terrain variables.\n    \"\"\"\n\n    gausian_bands = [\"Elevation\", \"Slope\", \"GaussianCurvature\"]\n    gausian_dataset = gaussian_filter()(dataset)\n    gausian_dataset = compute_terrain_variables(gausian_dataset, geom, gausian_bands)\n\n    pm_bands = [\"HorizontalCurvature\", \"VerticalCurvature\", \"MeanCurvature\"]\n    pm_dataset = perona_malik()(dataset)\n    pm_dataset = compute_terrain_variables(pm_dataset, geom, selectors=pm_bands)\n\n    return gausian_dataset.addBands(pm_dataset)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.compute_fourier_transform","title":"<code>compute_fourier_transform(dataset, dependent, modes=3)</code>","text":"<p>Computes the Fourier transform of the given dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>ee.ImageCollection</code> <p>The input dataset. Assumed to have inital pre processing done</p> required <code>dependent</code> <code>str</code> <p>The dependent variable.</p> required <code>modes</code> <code>int</code> <p>The number of Fourier modes to compute. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The Fourier transform of the dataset.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def compute_fourier_transform(dataset: ee.ImageCollection, dependent: str, modes: int = 3) -&gt; ee.Image:\n    \"\"\"\n    Computes the Fourier transform of the given dataset.\n\n    Args:\n        dataset (ee.ImageCollection): The input dataset. Assumed to have inital pre processing done\n        dependent (str): The dependent variable.\n        modes (int, optional): The number of Fourier modes to compute. Defaults to 3.\n\n    Returns:\n        ee.Image: The Fourier transform of the dataset.\n    \"\"\"\n    return (\n        HarmonicTimeSeries(dataset=dataset, dependent=dependent, modes=modes)\n        .add_constant()\n        .add_time()\n        .add_harmonics()\n        .set_harmonic_trend()\n        .add_harmonic_coefficients()\n        .add_phase()\n        .add_amplitue()\n        .transform()\n    )\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.compute_harmonic_trend_coefficients","title":"<code>compute_harmonic_trend_coefficients(harmonic_trend, independents)</code>","text":"<p>Compute the harmonic trend coefficients for a given harmonic trend image.</p> <p>Parameters:</p> Name Type Description Default <code>harmonic_trend</code> <code>ee.Image</code> <p>The harmonic trend image.</p> required <code>independents</code> <code>list[str]</code> <p>The list of independent variables.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The harmonic trend coefficients image.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def compute_harmonic_trend_coefficients(harmonic_trend: ee.Image, independents: list[str]) -&gt; ee.Image:\n    \"\"\"\n    Compute the harmonic trend coefficients for a given harmonic trend image.\n\n    Args:\n        harmonic_trend (ee.Image): The harmonic trend image.\n        independents (list[str]): The list of independent variables.\n\n    Returns:\n        ee.Image: The harmonic trend coefficients image.\n    \"\"\"\n    return harmonic_trend.select('coefficients').arrayFlatten([independents, ['coef']])\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.compute_terrain_variables","title":"<code>compute_terrain_variables(dataset, geom, selectors=None)</code>","text":"<p>Computes terrain variables for a given dataset within a specified geometry.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>ee.Image</code> <p>The input dataset for terrain analysis.</p> required <code>geom</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The geometry or feature collection representing the region of interest.</p> required <code>selectors</code> <code>list[str]</code> <p>The list of band names to select from the computed terrain variables. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The computed terrain variables dataset.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def compute_terrain_variables(dataset: ee.Image, geom: ee.Geometry | ee.FeatureCollection, selectors: list[str] = None) -&gt; ee.Image:\n    \"\"\"\n    Computes terrain variables for a given dataset within a specified geometry.\n\n    Args:\n        dataset (ee.Image): The input dataset for terrain analysis.\n        geom (ee.Geometry | ee.FeatureCollection): The geometry or feature collection representing the region of interest.\n        selectors (list[str], optional): The list of band names to select from the computed terrain variables. Defaults to None.\n\n    Returns:\n        ee.Image: The computed terrain variables dataset.\n    \"\"\"\n\n    from tagee import terrainAnalysis\n\n    if isinstance(geom, ee.FeatureCollection):\n        geom = geom.geometry()\n\n    coords = geom.bounds().coordinates()\n\n    rectangle = mk_rectangle(coords)\n    dataset = terrainAnalysis(dataset, rectangle)\n\n    if selectors is None:\n        return dataset\n    return dataset.select(selectors)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.compute_trend","title":"<code>compute_trend(dataset, independents, dependents)</code>","text":"<p>Computes the linear regression trend of the given dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>ee.ImageCollection</code> <p>The input image collection.</p> required <code>independents</code> <code>list[str]</code> <p>A list of independent variable names.</p> required <code>dependents</code> <code>str</code> <p>The dependent variable name.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The image representing the linear regression trend.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def compute_trend(dataset: ee.ImageCollection, independents: list[str], dependents: str) -&gt; ee.Image:\n    \"\"\"\n    Computes the linear regression trend of the given dataset.\n\n    Args:\n        dataset (ee.ImageCollection): The input image collection.\n        independents (list[str]): A list of independent variable names.\n        dependents (str): The dependent variable name.\n\n    Returns:\n        ee.Image: The image representing the linear regression trend.\n\n    \"\"\"\n    return dataset.select(independents + [dependents]).reduce(ee.Reducer.linearRegression(len(independents), 1))\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.gaussian_filter","title":"<code>gaussian_filter(radius=3, sigma=2, units=None, normalize=True, magnitude=1.0)</code>","text":"<p>Applies a Gaussian filter to an image.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius of the Gaussian kernel. Default is 3.</p> <code>3</code> <code>sigma</code> <code>int</code> <p>The standard deviation of the Gaussian kernel. Default is 2.</p> <code>2</code> <code>units</code> <code>str</code> <p>The units of the radius. Default is None, which means 'pixels'.</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>Whether to normalize the kernel. Default is True.</p> <code>True</code> <code>magnitude</code> <code>float</code> <p>The magnitude of the kernel. Default is 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Callable</code> <p>A function that applies the Gaussian filter to an image.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def gaussian_filter(\n    radius: float = 3,\n    sigma: int = 2,\n    units: str = None,\n    normalize: bool = True,\n    magnitude: float = 1.0,\n) -&gt; Callable:\n    \"\"\"\n    Applies a Gaussian filter to an image.\n\n    Args:\n        radius (float): The radius of the Gaussian kernel. Default is 3.\n        sigma (int): The standard deviation of the Gaussian kernel. Default is 2.\n        units (str): The units of the radius. Default is None, which means 'pixels'.\n        normalize (bool): Whether to normalize the kernel. Default is True.\n        magnitude (float): The magnitude of the kernel. Default is 1.0.\n\n    Returns:\n        Callable: A function that applies the Gaussian filter to an image.\n\n    \"\"\"\n    units = \"pixels\" if units is None else units\n    return lambda image: image.convolve(\n        ee.Kernel.gaussian(\n            radius=radius,\n            sigma=sigma,\n            units=units,\n            normalize=normalize,\n            magnitude=magnitude,\n        )\n    )\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.get_assets","title":"<code>get_assets(parent)</code>","text":"<p>Retrieve assets that exist one level under the specified parent.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>str</code> <p>The parent asset path.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A DataFrame containing the retrieved assets.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def get_assets(parent: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieve assets that exist one level under the specified parent.\n\n    Args:\n        parent (str): The parent asset path.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the retrieved assets.\n    \"\"\"\n    response = ee.data.listAssets({'parent': parent}).get('assets', None)\n    if response is None:\n        return pd.DataFrame()\n    return pd.DataFrame(response)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.mk_dir","title":"<code>mk_dir(folder_path)</code>","text":"<p>Creates a directory in Google Earth Engine.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>The path of the folder to be created.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def mk_dir(folder_path: str) -&gt; None:\n    \"\"\"\n    Creates a directory in Google Earth Engine.\n\n    Args:\n        folder_path (str): The path of the folder to be created.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        ee.data.createAssetHome(folder_path) # try exceot here to handle the EE Execption if the folder already exits\n    except ee.ee_exception.EEException:\n        return None\n    return None\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.mk_rectangle","title":"<code>mk_rectangle(geometry)</code>","text":"<p>Creates a rectangle geometry from the given input geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>ee.Geometry</code> <p>The input geometry.</p> required <p>Returns:</p> Type Description <code>ee.Geometry</code> <p>The rectangle geometry.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def mk_rectangle(geometry: ee.Geometry) -&gt; ee.Geometry:\n    \"\"\"\n    Creates a rectangle geometry from the given input geometry.\n\n    Args:\n        geometry (ee.Geometry): The input geometry.\n\n    Returns:\n        ee.Geometry: The rectangle geometry.\n\n    \"\"\"\n    coords = geometry.bounds().coordinates()\n\n    listCoords = ee.Array.cat(coords, 1)\n    xCoords = listCoords.slice(1, 0, 1)\n    yCoords = listCoords.slice(1, 1, 2)\n\n    xMin = xCoords.reduce(\"min\", [0]).get([0, 0])\n    xMax = xCoords.reduce(\"max\", [0]).get([0, 0])\n    yMin = yCoords.reduce(\"min\", [0]).get([0, 0])\n    yMax = yCoords.reduce(\"max\", [0]).get([0, 0])\n\n    return ee.Geometry.Rectangle(xMin, yMin, xMax, yMax)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.monitor_task","title":"<code>monitor_task(task)</code>","text":"<p>Monitors the status of a given Earth Engine batch task and returns the status code.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>ee.batch.Task</code> <p>The Earth Engine batch task to monitor.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The status code of the task. Possible values are:     - 0: COMPLETED     - 1: FAILED     - 2: CANCELLED</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def monitor_task(task: ee.batch.Task) -&gt; int:\n    \"\"\"\n    Monitors the status of a given Earth Engine batch task and returns the status code.\n\n    Args:\n        task (ee.batch.Task): The Earth Engine batch task to monitor.\n\n    Returns:\n        int: The status code of the task. Possible values are:\n            - 0: COMPLETED\n            - 1: FAILED\n            - 2: CANCELLED\n    \"\"\"\n    import time\n    while task.status()['state'] in ['READY', 'RUNNING']:\n        time.sleep(5)\n\n    status_code = {\n        'COMPLETED': 0,\n        'FAILED': 1,\n        'CANCELLED': 2\n    }\n\n    return status_code[task.status()['state']]\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.perona_malik","title":"<code>perona_malik(K=3.5, iterations=10, method=2)</code>","text":"<p>Applies the Perona-Malik anisotropic diffusion algorithm to an image.</p> <p>Parameters:</p> Name Type Description Default <code>K</code> <code>float</code> <p>The diffusion coefficient. Defaults to 3.5.</p> <code>3.5</code> <code>iterations</code> <code>int</code> <p>The number of iterations to perform. Defaults to 10.</p> <code>10</code> <code>method</code> <code>int</code> <p>The diffusion method to use. 1 for exponential diffusion, 2 for quadratic diffusion. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>Callable</code> <p>A function that applies the Perona-Malik algorithm to an image.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def perona_malik(K=3.5, iterations=10, method=2) -&gt; Callable:\n    \"\"\"\n    Applies the Perona-Malik anisotropic diffusion algorithm to an image.\n\n    Args:\n        K (float, optional): The diffusion coefficient. Defaults to 3.5.\n        iterations (int, optional): The number of iterations to perform. Defaults to 10.\n        method (int, optional): The diffusion method to use. 1 for exponential diffusion, 2 for quadratic diffusion. Defaults to 2.\n\n    Returns:\n        Callable: A function that applies the Perona-Malik algorithm to an image.\n\n    \"\"\"\n\n    def wrapper(img: ee.Image):\n        dxW = ee.Kernel.fixed(3, 3, [[0, 0, 0], [1, -1, 0], [0, 0, 0]])\n\n        dxE = ee.Kernel.fixed(3, 3, [[0, 0, 0], [0, -1, 1], [0, 0, 0]])\n\n        dyN = ee.Kernel.fixed(3, 3, [[0, 1, 0], [0, -1, 0], [0, 0, 0]])\n\n        dyS = ee.Kernel.fixed(3, 3, [[0, 0, 0], [0, -1, 0], [0, 1, 0]])\n\n        lamb = 0.2\n\n        k1 = ee.Image(-1.0 / K)\n        k2 = ee.Image(K).multiply(ee.Image(K))\n\n        for _ in range(0, iterations):\n            dI_W = img.convolve(dxW)\n            dI_E = img.convolve(dxE)\n            dI_N = img.convolve(dyN)\n            dI_S = img.convolve(dyS)\n\n            if method == 1:\n                cW = dI_W.multiply(dI_W).multiply(k1).exp()\n                cE = dI_E.multiply(dI_E).multiply(k1).exp()\n                cN = dI_N.multiply(dI_N).multiply(k1).exp()\n                cS = dI_S.multiply(dI_S).multiply(k1).exp()\n\n                img = img.add(\n                    ee.Image(lamb).multiply(\n                        cN.multiply(dI_N)\n                        .add(cS.multiply(dI_S))\n                        .add(cE.multiply(dI_E))\n                        .add(cW.multiply(dI_W))\n                    )\n                )\n\n            else:\n                cW = ee.Image(1.0).divide(\n                    ee.Image(1.0).add(dI_W.multiply(dI_W).divide(k2))\n                )\n                cE = ee.Image(1.0).divide(\n                    ee.Image(1.0).add(dI_E.multiply(dI_E).divide(k2))\n                )\n                cN = ee.Image(1.0).divide(\n                    ee.Image(1.0).add(dI_N.multiply(dI_N).divide(k2))\n                )\n                cS = ee.Image(1.0).divide(\n                    ee.Image(1.0).add(dI_S.multiply(dI_S).divide(k2))\n                )\n\n                img = img.add(\n                    ee.Image(lamb).multiply(\n                        cN.multiply(dI_N)\n                        .add(cS.multiply(dI_S))\n                        .add(cE.multiply(dI_E))\n                        .add(cW.multiply(dI_W))\n                    )\n                )\n\n        return img\n\n    return wrapper\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.preprocessing","title":"<code>preprocessing(self, *args)</code>","text":"<p>Preprocesses the input arguments and returns an ImageCollection filtered by the specified AOI and date range.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list containing the AOI, start date, and end date.</p> <code>()</code> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>The filtered ImageCollection.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def preprocessing(self, *args) -&gt; ee.ImageCollection:\n    \"\"\"\n    Preprocesses the input arguments and returns an ImageCollection filtered by the specified AOI and date range.\n\n    Args:\n        *args: Variable length argument list containing the AOI, start date, and end date.\n\n    Returns:\n        ee.ImageCollection: The filtered ImageCollection.\n\n    \"\"\"\n    aoi, start_date, end_date = args\n    return self.filterBounds(aoi).filterDate(start_date, end_date)\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.reset_processing_env","title":"<code>reset_processing_env()</code>","text":"<p>Resets the processing environment for Google Earth Engine.</p> <p>This function resets the processing environment for Google Earth Engine by calling the <code>ee.Reset()</code> and <code>ee.Initialize()</code> functions. It does not take any arguments and does not return any value.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def reset_processing_env() -&gt; None:\n    \"\"\"\n    Resets the processing environment for Google Earth Engine.\n\n    This function resets the processing environment for Google Earth Engine by calling the `ee.Reset()` and `ee.Initialize()` functions.\n    It does not take any arguments and does not return any value.\n    \"\"\"\n    ee.Reset()\n    ee.Initialize()\n    return None\n</code></pre>"},{"location":"gee_wetlands/#gee_wetlands.gee_wetlands.transform","title":"<code>transform(dataset)</code>","text":"<p>Transforms the given image collection into a single composite image.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>ee.ImageCollection</code> <p>The image collection to be transformed.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The transformed composite image.</p> Source code in <code>gee_wetlands/gee_wetlands.py</code> <pre><code>def transform(dataset: ee.ImageCollection) -&gt; ee.Image:\n    \"\"\"\n    Transforms the given image collection into a single composite image.\n\n    Args:\n        dataset (ee.ImageCollection): The image collection to be transformed.\n\n    Returns:\n        ee.Image: The transformed composite image.\n    \"\"\"\n    return dataset.composite().unitScale(-1, 1)\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install gee_wetlands, run this command in your terminal:</p> <pre><code>pip install gee_wetlands\n</code></pre> <p>This is the preferred method to install gee_wetlands, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install gee_wetlands from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/Hamilton97/gee_wetlands\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use gee_wetlands in a project:</p> <pre><code>import gee_wetlands\n</code></pre>"},{"location":"examples/fourier_transform/","title":"Fourier transform","text":"In\u00a0[1]: Copied! <pre>import ee\nimport geemap\n\nfrom gee_wetlands.gee_wetlands import compute_fourier_transform, Sentinel2TOA, add_ndvi\n</pre> import ee import geemap  from gee_wetlands.gee_wetlands import compute_fourier_transform, Sentinel2TOA, add_ndvi  In\u00a0[2]: Copied! <pre>ee.Initialize()\n</pre> ee.Initialize() In\u00a0[3]: Copied! <pre>DEPENDENT = 'NDVI'\nSTART_DATE = '2018'\nEND_DATE = '2021'\nAOI = ee.Geometry.Point([-77.3850, 44.1631])\nMODES = 3\n</pre> DEPENDENT = 'NDVI' START_DATE = '2018' END_DATE = '2021' AOI = ee.Geometry.Point([-77.3850, 44.1631]) MODES = 3  In\u00a0[4]: Copied! <pre>dataset = (\n        Sentinel2TOA()\n        .preprocessing(AOI, START_DATE, END_DATE)\n        .apply_cloud_mask()\n        .map(add_ndvi('B8', 'B4'))\n        .select('NDVI')\n    )\n\nfourier_transform = compute_fourier_transform(dataset, dependent=DEPENDENT, modes=MODES)\n</pre> dataset = (         Sentinel2TOA()         .preprocessing(AOI, START_DATE, END_DATE)         .apply_cloud_mask()         .map(add_ndvi('B8', 'B4'))         .select('NDVI')     )  fourier_transform = compute_fourier_transform(dataset, dependent=DEPENDENT, modes=MODES) In\u00a0[5]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(fourier_transform)\nMap.centerObject(AOI, 10)\nMap\n</pre> Map = geemap.Map() Map.addLayer(fourier_transform) Map.centerObject(AOI, 10) Map Out[5]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"},{"location":"examples/sentinel_1_dataset/","title":"Sentinel 1 dataset","text":"In\u00a0[1]: Copied! <pre>import ee\nimport geemap\n\nfrom gee_wetlands import gee_wetlands as gw\n</pre> import ee import geemap  from gee_wetlands import gee_wetlands as gw In\u00a0[2]: Copied! <pre>ee.Initialize()\n</pre> ee.Initialize() In\u00a0[3]: Copied! <pre>geom = ee.Geometry.Point([-77.3850, 44.1631])\ns1 = gw.Sentinel1().preprocessing(geom, '2020', '2021')\n</pre> geom = ee.Geometry.Point([-77.3850, 44.1631]) s1 = gw.Sentinel1().preprocessing(geom, '2020', '2021') In\u00a0[4]: Copied! <pre>vis = {'bands': ['VV'], 'min': -25, 'max': 10}\nMap = geemap.Map()\nMap.addLayer(s1.composite(), vis_params=vis)\nMap.centerObject(geom, 10)\nMap\n</pre> vis = {'bands': ['VV'], 'min': -25, 'max': 10} Map = geemap.Map() Map.addLayer(s1.composite(), vis_params=vis) Map.centerObject(geom, 10) Map Out[4]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/sentinel_2_dataset/","title":"Sentinel 2 dataset","text":"In\u00a0[1]: Copied! <pre>import ee\nimport geemap\n\nfrom gee_wetlands import gee_wetlands\n</pre> import ee import geemap  from gee_wetlands import gee_wetlands  In\u00a0[2]: Copied! <pre>ee.Initialize()\n</pre> ee.Initialize() In\u00a0[3]: Copied! <pre>aoi = ee.Geometry.Point([-77.3850, 44.1631])\nstart_date = '2019-06-20'\nend_date = '2019-09-21'\n</pre> aoi = ee.Geometry.Point([-77.3850, 44.1631]) start_date = '2019-06-20' end_date = '2019-09-21' In\u00a0[4]: Copied! <pre>s2 = gee_wetlands.Sentinel2TOA().preprocessing(aoi, start_date, end_date)\ns2.first()\n</pre> s2 = gee_wetlands.Sentinel2TOA().preprocessing(aoi, start_date, end_date) s2.first() Out[4]: <ul><li>Image COPERNICUS/S2_HARMONIZED/20190623T155829_20190623T160831_T17TQJ (16 bands)<ul><li>type:Image</li><li>id:COPERNICUS/S2_HARMONIZED/20190623T155829_20190623T160831_T17TQJ</li><li>version:1709821713661420.0</li><li>bands: List (16 elements)<ul><li>0: \"B1\", unsigned int16, EPSG:32617, 1830x1830 px<ul><li>id:B1</li><li>crs:EPSG:32617</li><li>crs_transform: [60, 0, 699960, 0, -60, 4900020]<ul><li>0:60</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-60</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [1830, 1830]<ul><li>0:1830</li><li>1:1830</li></ul></li></ul></li><li>1: \"B2\", unsigned int16, EPSG:32617, 10980x10980 px<ul><li>id:B2</li><li>crs:EPSG:32617</li><li>crs_transform: [10, 0, 699960, 0, -10, 4900020]<ul><li>0:10</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-10</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [10980, 10980]<ul><li>0:10980</li><li>1:10980</li></ul></li></ul></li><li>2: \"B3\", unsigned int16, EPSG:32617, 10980x10980 px<ul><li>id:B3</li><li>crs:EPSG:32617</li><li>crs_transform: [10, 0, 699960, 0, -10, 4900020]<ul><li>0:10</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-10</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [10980, 10980]<ul><li>0:10980</li><li>1:10980</li></ul></li></ul></li><li>3: \"B4\", unsigned int16, EPSG:32617, 10980x10980 px<ul><li>id:B4</li><li>crs:EPSG:32617</li><li>crs_transform: [10, 0, 699960, 0, -10, 4900020]<ul><li>0:10</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-10</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [10980, 10980]<ul><li>0:10980</li><li>1:10980</li></ul></li></ul></li><li>4: \"B5\", unsigned int16, EPSG:32617, 5490x5490 px<ul><li>id:B5</li><li>crs:EPSG:32617</li><li>crs_transform: [20, 0, 699960, 0, -20, 4900020]<ul><li>0:20</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-20</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [5490, 5490]<ul><li>0:5490</li><li>1:5490</li></ul></li></ul></li><li>5: \"B6\", unsigned int16, EPSG:32617, 5490x5490 px<ul><li>id:B6</li><li>crs:EPSG:32617</li><li>crs_transform: [20, 0, 699960, 0, -20, 4900020]<ul><li>0:20</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-20</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [5490, 5490]<ul><li>0:5490</li><li>1:5490</li></ul></li></ul></li><li>6: \"B7\", unsigned int16, EPSG:32617, 5490x5490 px<ul><li>id:B7</li><li>crs:EPSG:32617</li><li>crs_transform: [20, 0, 699960, 0, -20, 4900020]<ul><li>0:20</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-20</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [5490, 5490]<ul><li>0:5490</li><li>1:5490</li></ul></li></ul></li><li>7: \"B8\", unsigned int16, EPSG:32617, 10980x10980 px<ul><li>id:B8</li><li>crs:EPSG:32617</li><li>crs_transform: [10, 0, 699960, 0, -10, 4900020]<ul><li>0:10</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-10</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [10980, 10980]<ul><li>0:10980</li><li>1:10980</li></ul></li></ul></li><li>8: \"B8A\", unsigned int16, EPSG:32617, 5490x5490 px<ul><li>id:B8A</li><li>crs:EPSG:32617</li><li>crs_transform: [20, 0, 699960, 0, -20, 4900020]<ul><li>0:20</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-20</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [5490, 5490]<ul><li>0:5490</li><li>1:5490</li></ul></li></ul></li><li>9: \"B9\", unsigned int16, EPSG:32617, 1830x1830 px<ul><li>id:B9</li><li>crs:EPSG:32617</li><li>crs_transform: [60, 0, 699960, 0, -60, 4900020]<ul><li>0:60</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-60</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [1830, 1830]<ul><li>0:1830</li><li>1:1830</li></ul></li></ul></li><li>10: \"B10\", unsigned int16, EPSG:32617, 1830x1830 px<ul><li>id:B10</li><li>crs:EPSG:32617</li><li>crs_transform: [60, 0, 699960, 0, -60, 4900020]<ul><li>0:60</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-60</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [1830, 1830]<ul><li>0:1830</li><li>1:1830</li></ul></li></ul></li><li>11: \"B11\", unsigned int16, EPSG:32617, 5490x5490 px<ul><li>id:B11</li><li>crs:EPSG:32617</li><li>crs_transform: [20, 0, 699960, 0, -20, 4900020]<ul><li>0:20</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-20</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [5490, 5490]<ul><li>0:5490</li><li>1:5490</li></ul></li></ul></li><li>12: \"B12\", unsigned int16, EPSG:32617, 5490x5490 px<ul><li>id:B12</li><li>crs:EPSG:32617</li><li>crs_transform: [20, 0, 699960, 0, -20, 4900020]<ul><li>0:20</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-20</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [5490, 5490]<ul><li>0:5490</li><li>1:5490</li></ul></li></ul></li><li>13: \"QA10\", unsigned int16, EPSG:32617, 10980x10980 px<ul><li>id:QA10</li><li>crs:EPSG:32617</li><li>crs_transform: [10, 0, 699960, 0, -10, 4900020]<ul><li>0:10</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-10</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [10980, 10980]<ul><li>0:10980</li><li>1:10980</li></ul></li></ul></li><li>14: \"QA20\", unsigned int32, EPSG:32617, 5490x5490 px<ul><li>id:QA20</li><li>crs:EPSG:32617</li><li>crs_transform: [20, 0, 699960, 0, -20, 4900020]<ul><li>0:20</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-20</li><li>5:4900020</li></ul></li><li>data_type: unsigned int32<ul><li>type:PixelType</li><li>max:4294967295</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [5490, 5490]<ul><li>0:5490</li><li>1:5490</li></ul></li></ul></li><li>15: \"QA60\", unsigned int16, EPSG:32617, 1830x1830 px<ul><li>id:QA60</li><li>crs:EPSG:32617</li><li>crs_transform: [60, 0, 699960, 0, -60, 4900020]<ul><li>0:60</li><li>1:0</li><li>2:699960</li><li>3:0</li><li>4:-60</li><li>5:4900020</li></ul></li><li>data_type: unsigned int16<ul><li>type:PixelType</li><li>max:65535</li><li>min:0</li><li>precision:int</li></ul></li><li>dimensions: [1830, 1830]<ul><li>0:1830</li><li>1:1830</li></ul></li></ul></li></ul></li><li>properties: Object (66 properties)<ul><li>CLOUDY_PIXEL_PERCENTAGE:0</li><li>CLOUD_COVERAGE_ASSESSMENT:0</li><li>DATASTRIP_ID:S2B_OPER_MSI_L1C_DS_MTI__20190623T192205_S20190623T160831_N02.07</li><li>DATATAKE_IDENTIFIER:GS2B_20190623T155829_011992_N02.07</li><li>DATATAKE_TYPE:INS-NOBS</li><li>DEGRADED_MSI_DATA_PERCENTAGE:0</li><li>FORMAT_CORRECTNESS:PASSED</li><li>GENERAL_QUALITY:PASSED</li><li>GENERATION_TIME:1561317725000</li><li>GEOMETRIC_QUALITY:PASSED</li><li>GRANULE_ID:L1C_T17TQJ_A011992_20190623T160831</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B1:101.482534993</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B10:103.17609538</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B11:102.372763407</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B12:101.779501082</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B2:104.910517058</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B3:103.682279449</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B4:102.868701462</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B5:102.53113257</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B6:102.202219724</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B7:101.947396261</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B8:104.240193438</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B8A:101.708625206</li><li>MEAN_INCIDENCE_AZIMUTH_ANGLE_B9:101.303990456</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B1:5.470842681</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B10:5.1960250455</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B11:5.29476346642</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B12:5.41965464397</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B2:5.0888826181</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B3:5.1443124215</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B4:5.21224114561</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B5:5.25525480295</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B6:5.3035467908</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B7:5.35413789902</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B8:5.11399221968</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B8A:5.40820146931</li><li>MEAN_INCIDENCE_ZENITH_ANGLE_B9:5.52848075431</li><li>MEAN_SOLAR_AZIMUTH_ANGLE:142.751824138</li><li>MEAN_SOLAR_ZENITH_ANGLE:23.9888469652</li><li>MGRS_TILE:17TQJ</li><li>PROCESSING_BASELINE:02.07</li><li>PRODUCT_ID:S2B_MSIL1C_20190623T155829_N0207_R097_T17TQJ_20190623T192205</li><li>RADIOMETRIC_QUALITY:PASSED</li><li>REFLECTANCE_CONVERSION_CORRECTION:0.968456360619</li><li>SENSING_ORBIT_DIRECTION:DESCENDING</li><li>SENSING_ORBIT_NUMBER:97</li><li>SENSOR_QUALITY:PASSED</li><li>SOLAR_IRRADIANCE_B1:1874.3</li><li>SOLAR_IRRADIANCE_B10:365.41</li><li>SOLAR_IRRADIANCE_B11:247.08</li><li>SOLAR_IRRADIANCE_B12:87.75</li><li>SOLAR_IRRADIANCE_B2:1959.77</li><li>SOLAR_IRRADIANCE_B3:1824.93</li><li>SOLAR_IRRADIANCE_B4:1512.79</li><li>SOLAR_IRRADIANCE_B5:1425.78</li><li>SOLAR_IRRADIANCE_B6:1291.13</li><li>SOLAR_IRRADIANCE_B7:1175.57</li><li>SOLAR_IRRADIANCE_B8:1041.28</li><li>SOLAR_IRRADIANCE_B8A:953.93</li><li>SOLAR_IRRADIANCE_B9:817.58</li><li>SPACECRAFT_NAME:Sentinel-2B</li><li>system:asset_size:960051345</li><li>system:footprint: LinearRing (21 vertices)<ul><li>type:LinearRing</li><li>coordinates: List (21 elements)<ul><li>0: [-78.49654955849194, 44.226000053074074]<ul><li>0:-78.49654955849194</li><li>1:44.226000053074074</li></ul></li><li>1: [-78.49655415363002, 44.225985379081884]<ul><li>0:-78.49655415363002</li><li>1:44.225985379081884</li></ul></li><li>2: [-78.51722722556843, 43.73224204385439]<ul><li>0:-78.51722722556843</li><li>1:43.73224204385439</li></ul></li><li>3: [-78.53738077601473, 43.23845577359539]<ul><li>0:-78.53738077601473</li><li>1:43.23845577359539</li></ul></li><li>4: [-78.53733224311652, 43.238413183419574]<ul><li>0:-78.53733224311652</li><li>1:43.238413183419574</li></ul></li><li>5: [-78.53729142346448, 43.23836663654641]<ul><li>0:-78.53729142346448</li><li>1:43.23836663654641</li></ul></li><li>6: [-78.53727123029722, 43.238363354124544]<ul><li>0:-78.53727123029722</li><li>1:43.238363354124544</li></ul></li><li>7: [-77.1876084480185, 43.20130935149309]<ul><li>0:-77.1876084480185</li><li>1:43.20130935149309</li></ul></li><li>8: [-77.18754930978285, 43.20134400721385]<ul><li>0:-77.18754930978285</li><li>1:43.20134400721385</li></ul></li><li>9: [-77.18748473149782, 43.20137295638866]<ul><li>0:-77.18748473149782</li><li>1:43.20137295638866</li></ul></li><li>10: [-77.18747990567347, 43.201387603308014]<ul><li>0:-77.18747990567347</li><li>1:43.201387603308014</li></ul></li><li>11: [-77.17200484719832, 43.447975631475735]<ul><li>0:-77.17200484719832</li><li>1:43.447975631475735</li></ul></li><li>12: [-77.15633302294901, 43.69454093126982]<ul><li>0:-77.15633302294901</li><li>1:43.69454093126982</li></ul></li><li>13: [-77.14046084838482, 43.94109105359697]<ul><li>0:-77.14046084838482</li><li>1:43.94109105359697</li></ul></li><li>14: [-77.12438535090624, 44.18762582663584]<ul><li>0:-77.12438535090624</li><li>1:44.18762582663584</li></ul></li><li>15: [-77.124433546922, 44.1876689517556]<ul><li>0:-77.124433546922</li><li>1:44.1876689517556</li></ul></li><li>16: [-77.12447384193668, 44.18771609028637]<ul><li>0:-77.12447384193668</li><li>1:44.18771609028637</li></ul></li><li>17: [-77.12449429669925, 44.187719567097425]<ul><li>0:-77.12449429669925</li><li>1:44.187719567097425</li></ul></li><li>18: [-78.49642505618117, 44.226065095371425]<ul><li>0:-78.49642505618117</li><li>1:44.226065095371425</li></ul></li><li>19: [-78.4964845329308, 44.22602979228224]<ul><li>0:-78.4964845329308</li><li>1:44.22602979228224</li></ul></li><li>20: [-78.49654955849194, 44.226000053074074]<ul><li>0:-78.49654955849194</li><li>1:44.226000053074074</li></ul></li></ul></li></ul></li><li>system:index:20190623T155829_20190623T160831_T17TQJ</li><li>system:time_end:1561306280000</li><li>system:time_start:1561306280000</li></ul></li></ul></li></ul> In\u00a0[5]: Copied! <pre>s2_vis = {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 3000}\n</pre> s2_vis = {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 3000} In\u00a0[6]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(s2, s2_vis)\nMap.centerObject(aoi, 10)\nMap\n</pre> Map = geemap.Map() Map.addLayer(s2, s2_vis) Map.centerObject(aoi, 10) Map Out[6]: In\u00a0[7]: Copied! <pre># s2 with ndvi\ns2_ndvi = s2.map(gee_wetlands.add_ndvi('B8', 'B4'))\n</pre> # s2 with ndvi s2_ndvi = s2.map(gee_wetlands.add_ndvi('B8', 'B4')) In\u00a0[8]: Copied! <pre>s2_ndvi_vis = {'min': -1, 'max': 1, 'palette': ['blue', 'white', 'green'], 'bands': ['NDVI']}\n</pre> s2_ndvi_vis = {'min': -1, 'max': 1, 'palette': ['blue', 'white', 'green'], 'bands': ['NDVI']} In\u00a0[9]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(s2_ndvi, s2_ndvi_vis)\nMap.centerObject(aoi, 10)\nMap\n</pre> Map = geemap.Map() Map.addLayer(s2_ndvi, s2_ndvi_vis) Map.centerObject(aoi, 10) Map Out[9]: In\u00a0[10]: Copied! <pre># s2 with SAVI\ns2_savi = s2.map(gee_wetlands.add_savi('B8', 'B4'))\n</pre> # s2 with SAVI s2_savi = s2.map(gee_wetlands.add_savi('B8', 'B4')) In\u00a0[11]: Copied! <pre>s2_savi_vis = {'min': -1, 'max': 1, 'palette': ['blue', 'white', 'green'], 'bands': ['SAVI']}\n</pre> s2_savi_vis = {'min': -1, 'max': 1, 'palette': ['blue', 'white', 'green'], 'bands': ['SAVI']} In\u00a0[12]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(s2_savi, s2_savi_vis)\nMap.centerObject(aoi, 10)\nMap\n</pre> Map = geemap.Map() Map.addLayer(s2_savi, s2_savi_vis) Map.centerObject(aoi, 10) Map Out[12]: In\u00a0[13]: Copied! <pre># tasseled cap transformation\ns2_tasseled_cap = s2.map(gee_wetlands.add_tasseled_cap('B2', 'B3', 'B4', 'B8', 'B11', 'B12'))\ntasseled_cap_vis = {\n  'bands': ['brightness', 'greenness', 'wetness'],\n  'min': -0.1, 'max': [0.5, 0.1, 0.1]\n}\n</pre> # tasseled cap transformation s2_tasseled_cap = s2.map(gee_wetlands.add_tasseled_cap('B2', 'B3', 'B4', 'B8', 'B11', 'B12')) tasseled_cap_vis = {   'bands': ['brightness', 'greenness', 'wetness'],   'min': -0.1, 'max': [0.5, 0.1, 0.1] } In\u00a0[14]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(s2_tasseled_cap, tasseled_cap_vis)\nMap.centerObject(aoi, 10)\nMap\n</pre> Map = geemap.Map() Map.addLayer(s2_tasseled_cap, tasseled_cap_vis) Map.centerObject(aoi, 10) Map Out[14]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}